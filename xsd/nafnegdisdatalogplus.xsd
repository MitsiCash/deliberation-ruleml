<?xml version="1.0" encoding="UTF-8"?><!--
  Call parameters
  GET parameter: backbone=x7
  GET parameter: default=x7
  GET parameter: termseq=x7
  GET parameter: lng=x1
  GET parameter: propo=x3ff
  GET parameter: implies=x7f
  GET parameter: terms=xf3f
  GET parameter: quant=x7
  GET parameter: expr=x0
  GET parameter: serial=x53
--><xs:schema xmlns:ruleml="http://ruleml.org/spec" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://ruleml.org/spec"><xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2009/01/xml.xsd"/><xs:include schemaLocation="http://deliberation.ruleml.org/1.03/datatypes/SimpleWithAttributes.xsd"/><!-- dc:rights [ 'Copyright 2015 RuleML Inc. - Licensed under the RuleML Specification License, Version 1.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing permissions and limitations under the License.' ]    
-->
    
    
    
    
    <xs:element name="RuleML" type="ruleml:RuleML.type.def">
        <xs:annotation>
            <xs:documentation>The polyadic top_level of a RuleML document. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-RuleML</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="RuleML.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:RuleML.header"/>
            <xs:group ref="ruleml:RuleML.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reRuleML.attlist"/>
    </xs:complexType>
    <xs:group name="RuleML.header">
        <xs:annotation>
            <xs:documentation>The RuleML root element accepts the header pattern common to
                Nodes.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:Node.header"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="RuleML.main">
        <xs:annotation>
            <xs:documentation>The RuleML root element contains zero or more
                performatives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:act-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="act-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in assertions and retractions.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="ruleml:act"/>
            <xs:group ref="ruleml:act.content"/>
        </xs:choice>
    </xs:group>
    <xs:element name="act" type="ruleml:act.type.def">
        <xs:annotation>
            <xs:documentation>The action edge of a RuleML root which associates zero to many
                performatives with the root. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-act</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="act.type.def">
        <xs:annotation>
            <xs:documentation>The type of the action edge</xs:documentation>
        </xs:annotation>
        <xs:group ref="ruleml:act.content"/>
        <xs:attributeGroup ref="ruleml:act-datt.choice"/>
        <xs:attributeGroup ref="ruleml:react.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="act-datt.choice">
        <xs:annotation>
            <xs:documentation>The attribute @index is required for the positional argument
                edge.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:index.attrib.def"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="react.attlist">
        <xs:annotation>
            <xs:documentation>The action type accepts the common attributes. </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="act.content">
        <xs:annotation>
            <xs:documentation>contains one performative.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Performative.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Performative.choice">
        <xs:annotation>
            <xs:documentation>Performatives include assertions, retractions and
                queries.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:AssertRetract-node.choice"/>
            <xs:group ref="ruleml:Query-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="AssertRetract-node.choice">
        <xs:annotation>
            <xs:documentation>a convenience pattern combining assertions and
                retractions</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Assert-node.choice"/>
            <xs:group ref="ruleml:Retract-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="Assert-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the assertion tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Assert"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Assert" type="ruleml:Assert.type.def">
        <xs:annotation>
            <xs:documentation>A KQML-like performative acting as a wrapper specifying that its
                content is  asserted, making an 'implicit &lt;Rulebase&gt;' assumption. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Assert</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Assert.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:AssertRetract.header"/>
            <xs:group ref="ruleml:AssertRetract.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:AssertRetract-datt.choice"/>
        <xs:attributeGroup ref="ruleml:reAssertRetract.attlist"/>
    </xs:complexType>
    <xs:group name="Retract-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the retraction tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Retract"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Retract" type="ruleml:Retract.type.def">
        <xs:annotation>
            <xs:documentation>A performative similar to KQML's 'untell' that acts as a wrapper
                specifying that its content is to be deleted, making an 'implicit &lt;Rulebase&gt;'
                assumption. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Retract</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Retract.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:AssertRetract.header"/>
            <xs:group ref="ruleml:AssertRetract.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:AssertRetract-datt.choice"/>
        <xs:attributeGroup ref="ruleml:reAssertRetract.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reAssertRetract.attlist">
        <xs:annotation>
            <xs:documentation>Assertions and retractions may have an optional scope closure
                attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:mapClosure-att.choice"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="AssertRetract.header">
        <xs:annotation>
            <xs:documentation>Assertions and retractions accept the header pattern common to
                Nodes.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:Node.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="AssertRetract.main">
        <xs:annotation>
            <xs:documentation>Assertions and retractions contain zero or more
                formulas.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_AssertRetract-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_AssertRetract-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in assertions and retractions.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_AssertRetract.edge.def"/>
            <xs:group ref="ruleml:formula_AssertRetract.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_AssertRetract.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_AssertRetract.type.def">
                <xs:annotation>
                    <xs:documentation>The formula edge of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;)
                        expression,  quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt;
                        or &lt;Retract&gt;). See http://deliberation.ruleml.org/1.03/glossary/#gloss-formula
                        Within Assert or Retract...</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_AssertRetract.type.def">
        <xs:group ref="ruleml:formula_AssertRetract.content"/>
        <xs:attributeGroup ref="ruleml:formula_AssertRetract.attlist"/>
    </xs:complexType>
    <xs:group name="formula_AssertRetract.content">
        <xs:annotation>
            <xs:documentation>Forumulas within assertions and retractions contain a single
                formula.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:AssertRetractFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Query-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the query tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Query"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Query" type="ruleml:Query.type.def">
        <xs:annotation>
            <xs:documentation>A KQML-like performative acting as a wrapper specifying that its
                content is queried, making an 'implicit &lt;Rulebase&gt;' assumption. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Query</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Query.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Query.header"/>
            <xs:group ref="ruleml:Query.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reQuery.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reQuery.attlist">
        <xs:annotation>
            <xs:documentation>Queries may have an optional map closure attribute  and will accept a
                scoped closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="Query.header">
        <xs:annotation>
            <xs:documentation>Queries accept the header pattern common to Nodes.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:Node.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Query.main">
        <xs:annotation>
            <xs:documentation>The content model of queries consists of zero or more
                formulas.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_Query-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_Query-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in queries.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_Query.edge.def"/>
            <xs:group ref="ruleml:formula_Query.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Query.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Query.type.def">
                <xs:annotation>
                    <xs:documentation>The formula edge of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;)
                        expression,  quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt;
                        or &lt;Retract&gt;). See http://deliberation.ruleml.org/1.03/glossary/#gloss-formula
                        Within Query ...</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Query.type.def">
        <xs:group ref="ruleml:formula_Query.content"/>
        <xs:attributeGroup ref="ruleml:formula_Query.attlist"/>
    </xs:complexType>
    <xs:group name="formula_Query.content">
        <xs:annotation>
            <xs:documentation>The content model of a forumula within queries is a single
                formula.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:QueryFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:attributeGroup name="reRuleML.attlist">
        <xs:annotation>
            <xs:documentation>The RuleML type accepts the common Node attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula_AssertRetract.attlist">
        <xs:annotation>
            <xs:documentation>The Assert/Retract formula type accepts the common attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula_Query.attlist">
        <xs:annotation>
            <xs:documentation>The Query formula type accepts the common attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    <xs:group name="AssertRetractFormula.choice">
        <xs:annotation>
            <xs:documentation>Formulas allowed in assertions and retractions: Simple formulas are
                allowed in assertions and retractions in all sub-languages. Conjunctions and
                disjunctions are allowed in assertions and retractions in sub-languages that contain
                these components. Implications and universal quantifications is allowed in
                assertions and retractions for all quantified sub-languages. Strong and weak
                negation are allowed in assertions and retractions for all sub-languages that
                contain these components. Existential quantification is added to assertions and
                retractions for full first-order sub-languages.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:choice>
                <xs:group ref="ruleml:SimpleFormula-node.choice"/>
                <xs:group ref="ruleml:Negation-node.choice"/>
                <xs:group ref="ruleml:Implication-node.choice"/>
                <xs:group ref="ruleml:Forall-node.choice"/>
            </xs:choice>
            <xs:choice>
                <xs:group ref="ruleml:Entails-node.choice"/>
                <xs:group ref="ruleml:Rulebase-node.choice"/>
            </xs:choice>
        </xs:choice>
    </xs:group>
    
    
    <xs:group name="QueryFormula.choice">
        <xs:annotation>
            <xs:documentation>Formulas allowed in queries: Simple formulas are allowed in queries in
                all sub-languages. Conjunctions and disjunctions are allowed in queries in
                sub-languages that contain these components. Existential quantifications is allowed
                in queries for all quantified sub-languages. Strong and weak negation are allowed in
                queries for all sub-languages that contain these components. Implications and
                universal quantification are added to queries for full first-order
                sub-languages.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:choice>
                <xs:group ref="ruleml:SimpleFormula-node.choice"/>
                <xs:group ref="ruleml:And-Query-node.choice"/>
                <xs:group ref="ruleml:Or-Query-node.choice"/>
                <xs:group ref="ruleml:Negation-node.choice"/>
                <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
                <xs:group ref="ruleml:Exists-node.choice"/>
            </xs:choice>
            <xs:choice>
                <xs:group ref="ruleml:Entails-node.choice"/>
                <xs:group ref="ruleml:Rulebase-node.choice"/>
            </xs:choice>
        </xs:choice>
    </xs:group>
    
    
    <xs:group name="SimpleFormula-node.choice">
        <xs:annotation>
            <xs:documentation>atomic formulas are a kind of simple formula</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Atom-node.choice"/>
            <xs:group ref="ruleml:Equal-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="Atom-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the atomic formula tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Atom"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Atom" type="ruleml:Atom.type.def">
        <xs:annotation>
            <xs:documentation>&lt;Atom&gt;: a predicate applied to arguments. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Atom</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Atom.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Atom.header"/>
            <xs:group ref="ruleml:Atom.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reAtom.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reAtom.attlist">
        <xs:annotation>
            <xs:documentation>Atomic formulas may have an optional closure
                attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="operatorForAtoms-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the operator tag name in atomic formulas.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="ruleml:op"/>
            <xs:group ref="ruleml:op_Atom.content"/>
        </xs:choice>
    </xs:group>
    <xs:element name="op" type="ruleml:op.type.def">
        <xs:annotation>
            <xs:documentation>&lt;op&gt;: edge element for the predicate of an atomic formula. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-op</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="op.type.def">
        <xs:group ref="ruleml:op_Atom.content"/>
        <xs:attributeGroup ref="ruleml:op_Atom.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="op_Atom.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="op_Atom.content">
        <xs:annotation>
            <xs:documentation>The operator role in the context of an atomic formula is filled by a
                predicate.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Relation-node.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Relation-node.choice">
        <xs:annotation>
            <xs:documentation> </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Rel"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Rel" type="ruleml:Rel.type.def">
        <xs:annotation>
            <xs:documentation>&lt;Rel&gt;: symbol used as the predicate of an atomic formula. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Rel</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Rel.type.def">
        <xs:simpleContent>
            <xs:extension base="ruleml:Rel.value">
                <xs:attributeGroup ref="ruleml:reRel.attlist"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="reRel.attlist">
        <xs:annotation>
            <xs:documentation>Relations accept the optional attribute pattern of
                resources.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:Resource.attlist"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:type-att.choice"/>
    </xs:attributeGroup>
    <xs:simpleType name="Rel.value">
        <xs:annotation>
            <xs:documentation>The content model for relations is the XSD datatype
                token.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token"/>
    </xs:simpleType>
    
    <xs:group name="And-node.choice">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:And.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="And.Node.def">
        <xs:annotation>
            <xs:documentation>A polyadic conjunctive formula,  The children of the conjunction
                element are divided into two sections,  a header section for modifiers, and a main
                section for the formulas that are conjuncts.  Within anything other than
                Query...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="And" type="ruleml:And.type.def">
                <xs:annotation>
                    <xs:documentation>&lt;And&gt;: polyadic conjunction where &lt;And/&gt; is true. See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-And</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="And.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:And.header"/>
            <xs:group ref="ruleml:And.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reAnd.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reAnd.attlist">
        <xs:annotation>
            <xs:documentation>The attribute list of the conjunction element will accept a scoped
                closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="And.header">
        <xs:annotation>
            <xs:documentation>Conjunctions accept the header pattern common to truth-valued
                connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="And.main">
        <xs:annotation>
            <xs:documentation>The main section of the conjunction content model contains zero or
                more formula edges.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_And-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_And-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in conjunctions.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_And.edge.def"/>
            <xs:group ref="ruleml:formula_And.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_And.edge.def">
        <xs:annotation>
            <xs:documentation>A formula edge of a conjunction (&lt;And&gt;),  Within And
                ...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_And.type.def">
                <xs:annotation>
                    <xs:documentation>&lt;formula&gt;: contains a single formula. See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-formula</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_And.type.def">
        <xs:group ref="ruleml:formula_And.content"/>
        <xs:attributeGroup ref="ruleml:formula_And-datt.choice"/>
        <xs:attributeGroup ref="ruleml:formula_And.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="formula_And-datt.choice">
        <xs:attributeGroup ref="ruleml:index-attrib.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula_And.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="formula_And.content">
        <xs:annotation>
            <xs:documentation>Formulas within conjunctions consist of a single
                formula</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:AndFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="AndFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to participate in conjunctions. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:And-node.choice"/>
            <xs:group ref="ruleml:Or-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
            <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:group name="Or-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the disjunction tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Or.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Or.Node.def">
        <xs:annotation>
            <xs:documentation>A polyadic disjunctive formula,  The children of the disjunction
                element are divided into two sections,  a header section for modifiers, and a main
                section for the formulas that are disjuncts.  Within anything other than
                Query...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="Or" type="ruleml:Or.type.def">
                <xs:annotation>
                    <xs:documentation>&lt;Or&gt;: polyadic disjunction where &lt;Or/&gt; is false. See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-Or</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Or.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Or.header"/>
            <xs:group ref="ruleml:Or.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reOr.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reOr.attlist">
        <xs:annotation>
            <xs:documentation>The attribute list of the disjunction element will accept a (scoped)
                closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Or.header">
        <xs:annotation>
            <xs:documentation>Disjunctions accept the header pattern common to truth-valued
                connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Or.main">
        <xs:annotation>
            <xs:documentation>The main section of the disjunction content model contains zero or
                more formula edges.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_Or-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_Or-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in disjunctions.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_Or.edge.def"/>
            <xs:group ref="ruleml:formula_Or.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Or.edge.def">
        <xs:annotation>
            <xs:documentation>A formula edge of a disjunction (&lt;Or&gt;), </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Or.type.def">
                <xs:annotation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Or.type.def">
        <xs:group ref="ruleml:formula_Or.content"/>
        <xs:attributeGroup ref="ruleml:formula_Or-datt.choice"/>
        <xs:attributeGroup ref="ruleml:formula_Or.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="formula_Or-datt.choice">
        <xs:attributeGroup ref="ruleml:index-attrib.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula_Or.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="formula_Or.content">
        <xs:annotation>
            <xs:documentation>Formulas within disjunctions consist of a single
                formula</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:OrFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="OrFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to participate in disjunctions. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:And-node.choice"/>
            <xs:group ref="ruleml:Or-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
            <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="And-Query-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the conjunction tag name in
                queries.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:And-Query.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="And-Query.Node.def">
        <xs:annotation>
            <xs:documentation>Within Query...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="And" type="ruleml:And-Query.type.def">
                <xs:annotation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="And-Query.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:And.header"/>
            <xs:group ref="ruleml:And.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reAnd-Query.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reAnd-Query.attlist">
        <xs:annotation>
            <xs:documentation>Within query, conjunctions may have an optional existential closure
                attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="Or-Query-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the disjunction tag name in
                queries.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Or-Query.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Or-Query.Node.def">
        <xs:annotation>
            <xs:documentation>Within Query...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="Or" type="ruleml:Or-Query.type.def">
                <xs:annotation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Or-Query.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Or.header"/>
            <xs:group ref="ruleml:Or.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reOr-Query.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reOr-Query.attlist">
        <xs:annotation>
            <xs:documentation>Within query, disjunctions may have an optional existential closure
                attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="Implication-node.choice">
        <xs:annotation>
            <xs:documentation>a convenience pattern that unifies implications and equivalences
                because equivalence is allowed wherever implication is allowed.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Implies-node.choice"/>
            <xs:group ref="ruleml:Equivalent-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:group name="Implies-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point to allow alternate names and internationalization
                of uni-directional implication tag name.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Implies"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Implies" type="ruleml:Implies.type.def">
        <xs:annotation>
            <xs:documentation>&lt;Implies&gt;: an implication between two formulas, a premise and a
                conclusion. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Implies</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Implies.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Implies.header"/>
            <xs:group ref="ruleml:Implies.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:Implies-datt.choice"/>
        <xs:attributeGroup ref="ruleml:reImplies.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reImplies.attlist">
        <xs:annotation>
            <xs:documentation>Implications may have an optional closure attribute  and will accept a
                scoped closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="Implies.header">
        <xs:annotation>
            <xs:documentation>Equations accept the header pattern of truth-valued
                connectives</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    
    <xs:group name="body_Implies.name.choice">
        <xs:annotation>
            <xs:documentation> an extension point for stripe skipping as well as specializations of
                the if tag name in implications.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:body_Implies.edge.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="body_Implies.edge.def">
        <xs:annotation>
            <xs:documentation>The if of an implication rule (&lt;Implies&gt;) containing the Premise(s),
                also known as the "antecedent" part of the rule.  Also used as the "antecedent" part
                of an entailment (&lt;Entails&gt;). Within Implies...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="if" type="ruleml:body_Implies.type.def">
                <xs:annotation>
                    <xs:documentation>&lt;if&gt;: contains the premise of the implication. See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-if</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="body_Implies.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:body_Implies.content">
                <xs:attributeGroup ref="ruleml:body_Implies.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:attributeGroup name="body_Implies.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="body_Implies.content">
        <xs:annotation>
            <xs:documentation>The premise of an implication consists of a single
                formula</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ruleml:PremiseFormula.choice"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="PremiseFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to be premises. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:And-node.choice"/>
            <xs:group ref="ruleml:Or-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
            <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
        </xs:choice>
    </xs:complexType>
    
    <xs:group name="head_Implies.name.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the then tag name in implications.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:head_Implies.edge.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="head_Implies.edge.def">
        <xs:annotation>
            <xs:documentation>The then of an implication rule (&lt;Implies&gt;) containing the conclusion,
                also known as the "consequent" or "then" part of the rule.  Also used as the
                "consequent" part of an entailment (&lt;Entails&gt;). Within Implies...</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="then" type="ruleml:head_Implies.type.def">
                <xs:annotation>
                    <xs:documentation>&lt;then&gt;: contains the conclusion of the implication. See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-then</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="head_Implies.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:head_Implies.content">
                <xs:attributeGroup ref="ruleml:head_Implies.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:attributeGroup name="head_Implies.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="head_Implies.content">
        <xs:annotation>
            <xs:documentation>The conclusion of an implication consists of a single
                formula.</xs:documentation>
        </xs:annotation>
        <xs:group ref="ruleml:ConclusionFormula.choice"/>
    </xs:complexType>
    <xs:group name="ConclusionFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to be conclusions include atomic formulas.
            </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Atom-head-node.choice"/>
            <xs:group ref="ruleml:Equal-head-node.choice"/>
            <xs:group ref="ruleml:And-head-node.choice"/>
            <xs:group ref="ruleml:Or-head-node.choice"/>
            <xs:group ref="ruleml:Negation-head-node.choice"/>
            <xs:group ref="ruleml:Exists-head-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="Atom-head-node.choice">
        <xs:annotation>
            <xs:documentation>backbone patterns    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Atom-node.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Equal-head-node.choice">
        <xs:sequence>
            <xs:group ref="ruleml:Equal-node.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="And-head-node.choice">
        <xs:sequence>
            <xs:group ref="ruleml:And-head.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Or-head-node.choice">
        <xs:sequence>
            <xs:group ref="ruleml:Or-head.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Negation-head-node.choice">
        <xs:sequence>
            <xs:group ref="ruleml:Negation-node.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Exists-head-node.choice">
        <xs:sequence>
            <xs:group ref="ruleml:Exists-head.Node.def"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Forall-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point to allow alternate names and internationalization
                of universal quantifiers</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Forall"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Forall" type="ruleml:Forall.type.def">
        <xs:annotation>
            <xs:documentation>Explicit universal quantifier. It consists of a sequence of one or
                more  variables (&lt;Var&gt;), each optionally surrounded by &lt;declare&gt; role tags, and a
                logical formula (optionally surrounded by &lt;formula&gt; role tags). See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Forall</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Forall.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Forall.header"/>
            <xs:group ref="ruleml:Forall.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reForall.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reForall.attlist">
        <xs:annotation>
            <xs:documentation>The attribute list of the universal quantification formula  will
                accept a scoped closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Forall.header">
        <xs:annotation>
            <xs:documentation>Universally qualified formulas aaccept the header pattern common to
                truth-valued connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Forall.main">
        <xs:annotation>
            <xs:documentation>Universally qualified formulas contain a sequence of bound variables
                and one formula.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:boundVariables.choice"/>
            <xs:group ref="ruleml:formula_Forall-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Exists-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point to allow alternate names and internationalization
                for existential quantifiers</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Exists.Node.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Exists.Node.def">
        <xs:annotation>
            <xs:documentation>The children of an existential quantification are divided into two
                sections,  a header section for modifiers, and a main section for the variable
                declarations and body formula. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="Exists" type="ruleml:Exists.type.def">
                <xs:annotation>
                    <xs:documentation>Explicit existential quantifier. It consists of one or more
                        variables (&lt;Var&gt;), each optionally surrounded by &lt;declare&gt; role tags, followed
                        by a logical formula  (optionally surrounded by &lt;formula&gt; role tags). See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-Exists</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Exists.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Exists.header"/>
            <xs:group ref="ruleml:Exists.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reExists.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reExists.attlist">
        <xs:annotation>
            <xs:documentation>The attribute list of the existential quantification formula  will
                accept a scoped closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Exists.header">
        <xs:annotation>
            <xs:documentation>Existential quantifications accept the header pattern common to
                truth-valued connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Exists.main">
        <xs:annotation>
            <xs:documentation>Existentially qualified formulas contain a sequence of bound variables
                and one formula.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:boundVariables.choice"/>
            <xs:group ref="ruleml:formula_Exists-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="boundVariables.choice">
        <xs:annotation>
            <xs:documentation>declaration of one or more bound quantifiable
                terms.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" ref="ruleml:declare-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="declare-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the declare tag name in quantified formulas.  </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="ruleml:declare"/>
            <xs:group ref="ruleml:declare.content"/>
        </xs:choice>
    </xs:group>
    <xs:element name="declare" type="ruleml:declare.type.def">
        <xs:annotation>
            <xs:documentation>An edge used for variables (&lt;Var&gt;) declared within a quantifier (&lt;Forall&gt;
                or &lt;Exists&gt;). See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-declare</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="declare.type.def">
        <xs:group ref="ruleml:declare.content"/>
        <xs:attributeGroup ref="ruleml:declare.attlist"/>
    </xs:complexType>
    <xs:group name="declare.content">
        <xs:annotation>
            <xs:documentation>The role filler for a quantification's declare edge is a simple
                quantifiable term</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:SimpleQuantifiableTerm.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_Forall-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in universal quantifications. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_Forall.edge.def"/>
            <xs:group ref="ruleml:formula_Forall.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Forall.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Forall.type.def">
                <xs:annotation>
                    <xs:documentation>The formula edge of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;)
                        expression,  quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt;
                        or &lt;Retract&gt;). See http://deliberation.ruleml.org/1.03/glossary/#gloss-formula
                        within Forall...</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Forall.type.def">
        <xs:group ref="ruleml:formula_Forall.content"/>
        <xs:attributeGroup ref="ruleml:formula_Forall.attlist"/>
    </xs:complexType>
    <xs:group name="formula_Forall.content">
        <xs:annotation>
            <xs:documentation>The role filler for an universal quantification's body edge is a
                formula. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:ForallFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="ForallFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to be universally quantified.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
            <xs:group ref="ruleml:Implication-node.choice"/>
            <xs:group ref="ruleml:Forall-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:group name="formula_Exists-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the formula tag name in existential quantifications. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_Exists.edge.def"/>
            <xs:group ref="ruleml:formula_Exists.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Exists.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Exists.type.def">
                <xs:annotation>
                    <xs:documentation>The formula edge of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;)
                        expression,  quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt;
                        or &lt;Retract&gt;). See http://deliberation.ruleml.org/1.03/glossary/#gloss-formula
                        Within Exists...</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Exists.type.def">
        <xs:group ref="ruleml:formula_Exists.content"/>
        <xs:attributeGroup ref="ruleml:formula_Exists.attlist"/>
    </xs:complexType>
    <xs:group name="formula_Exists.content">
        <xs:annotation>
            <xs:documentation>The role filler of an existential quantification's body edge is a
                formula.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:ExistsFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="ExistsFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to be existentially quantified.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:And-node.choice"/>
            <xs:group ref="ruleml:Or-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
            <xs:group ref="ruleml:Exists-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:attributeGroup name="declare.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula_Forall.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula_Exists.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    <xs:group name="Or-head.Node.def">
        <xs:sequence>
            <xs:element form="qualified" name="Or" type="ruleml:Or-head.type.def">
                <xs:annotation>
                    <xs:documentation>within the head of implications</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Or-head.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Or.header"/>
            <xs:group ref="ruleml:Or-head.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reOr.attlist"/>
    </xs:complexType>
    <xs:group name="Or-head.main">
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_Or-head-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_Or-head-edge.choice">
        <xs:choice>
            <xs:group ref="ruleml:formula_Or-head.edge.def"/>
            <xs:group ref="ruleml:formula_Or-head.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Or-head.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Or-head.type.def">
                <xs:annotation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Or-head.type.def">
        <xs:group ref="ruleml:formula_Or-head.content"/>
        <xs:attributeGroup ref="ruleml:formula_Or-datt.choice"/>
        <xs:attributeGroup ref="ruleml:formula_Or.attlist"/>
    </xs:complexType>
    <xs:group name="formula_Or-head.content">
        <xs:sequence>
            <xs:group ref="ruleml:OrHeadFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="OrHeadFormula.choice">
        <xs:choice>
            <xs:group ref="ruleml:Atom-node.choice"/>
            <xs:group ref="ruleml:And-head-node.choice"/>
            <xs:group ref="ruleml:Or-head-node.choice"/>
            <xs:group ref="ruleml:Negation-head-node.choice"/>
            <xs:group ref="ruleml:Exists-head-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:attributeGroup name="Implies-datt.choice">
        <xs:annotation>
            <xs:documentation>implications have inference direction and material implication as an
                attribute.  implications have scoped attributes that are activated at full
                first-order logic</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:direction-att-inf.choice"/>
        <xs:attributeGroup ref="ruleml:material-att-inf.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="Rulebase-datt.choice">
        <xs:annotation>
            <xs:documentation>rulebases have scope inference direction  and scope material
                implication as an attribute. </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:mapMaterial-att-inf.choice"/>
        <xs:attributeGroup ref="ruleml:mapDirection-att-inf.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="AssertRetract-datt.choice">
        <xs:annotation>
            <xs:documentation>assertions and retractions have scope inference direction  and  scope
                material implication as an attribute. </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:mapMaterial-att-inf.choice"/>
        <xs:attributeGroup ref="ruleml:mapDirection-att-inf.choice"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="Equal-datt.choice">
        <xs:annotation>
            <xs:documentation>equations have orientation as an attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:oriented-att-inf.choice"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="direction-att-inf.choice">
        <xs:attributeGroup ref="ruleml:direction-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="material-att-inf.choice">
        <xs:attributeGroup ref="ruleml:material-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="mapDirection-att-inf.choice">
        <xs:attributeGroup ref="ruleml:mapDirection-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="mapMaterial-att-inf.choice">
        <xs:attributeGroup ref="ruleml:mapMaterial-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="oriented-att-inf.choice">
        <xs:attributeGroup ref="ruleml:oriented-att.choice"/>
    </xs:attributeGroup>
    
    
    
    <xs:group name="termsForAtoms.nonemptysequence.choice">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" ref="ruleml:positionalArgument-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="termsForExpressions.nonemptysequence.choice">
        <xs:sequence>
            <xs:group maxOccurs="unbounded" ref="ruleml:positionalArgument-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom.main">
        <xs:annotation>
            <xs:documentation>The main section of an atomic formula contains an operator edge and a
                collection of argument edges. Pre-fix operator notation for atomic formulas is
                required in a deterministic serialization.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:operatorForAtoms-edge.choice"/>
            <xs:group ref="ruleml:argumentsForAtoms.sequence"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="argumentsForAtoms.sequence">
        <xs:annotation>
            <xs:documentation>Slotted arguments may precede or  follow positional arguments  in
                atomic formulas in the deterministic serialization. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:slotTermsForAtoms.sequence"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:sequence>
                        <xs:group ref="ruleml:termsForAtoms.nonemptysequence.choice"/>
                        <xs:group minOccurs="0" ref="ruleml:repo"/>
                    </xs:sequence>
                    <xs:group ref="ruleml:repo"/>
                </xs:choice>
                <xs:group ref="ruleml:slotTermsForAtoms.sequence"/>
            </xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:resl"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="repo">
        <xs:sequence>
            <xs:group ref="ruleml:restOfPositionalArguments-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="resl">
        <xs:sequence>
            <xs:group ref="ruleml:restOfSlots-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="positionalArgumentsForAtoms.sequence">
        <xs:annotation>
            <xs:documentation>Positional rest arguments in atomic formulas may occur in  any
                position relative to the slots in relaxed-form serialization.  This pattern cannot
                be translated accurately into XSD.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:sequence minOccurs="0">
                <xs:group ref="ruleml:termsForAtoms.sequence"/>
                <xs:group minOccurs="0" ref="ruleml:restOfPositionalArguments-edge.choice"/>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:group name="argumentsForExpressions.sequence">
        <xs:annotation>
            <xs:documentation>Slotted arguments may precede or  follow positional arguments  in the
                deterministic serialization. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:sequence minOccurs="0">
                <xs:group ref="ruleml:slotTermsForExpressions.sequence"/>
                <xs:sequence minOccurs="0">
                    <xs:choice>
                        <xs:sequence>
                            <xs:group ref="ruleml:termsForExpressions.nonemptysequence.choice"/>
                            <xs:group minOccurs="0" ref="ruleml:repo"/>
                        </xs:sequence>
                        <xs:group ref="ruleml:repo"/>
                    </xs:choice>
                    <xs:group ref="ruleml:slotTermsForExpressions.sequence"/>
                </xs:sequence>
                <xs:group minOccurs="0" ref="ruleml:resl"/>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:group name="positionalArgumentsForExpressions.sequence">
        <xs:annotation>
            <xs:documentation>Positional rest arguments follow the ordinary positional arguments in
                expressions in the deterministic serialization. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:sequence minOccurs="0">
                <xs:group ref="ruleml:termsForExpressions.sequence"/>
                <xs:group minOccurs="0" ref="ruleml:restOfPositionalArguments-edge.choice"/>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:group name="slotsForExpressions.sequence">
        <xs:annotation>
            <xs:documentation>Slotted rest arguments follow the ordinary slots in expressions in the
                deterministic serialization. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:sequence minOccurs="0">
                <xs:group ref="ruleml:slotTermsForExpressions.sequence"/>
                <xs:group minOccurs="0" ref="ruleml:resl"/>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:group name="Implies.main">
        <xs:annotation>
            <xs:documentation>The main section of an implication contains two edges, a premise
                (body, if) edge and a conclusion (head, then) edge. In the deterministic
                serialization, the if and then  of an implication can occur in either order if
                striped. This pattern can be translated accurately into XSD.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:sequence>
                <xs:group ref="ruleml:body_Implies.name.choice"/>
                <xs:group ref="ruleml:head_Implies.name.choice"/>
            </xs:sequence>
            <xs:sequence>
                <xs:group ref="ruleml:head_Implies.name.choice"/>
                <xs:group ref="ruleml:body_Implies.name.choice"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <xs:group name="Entails.main">
        <xs:annotation>
            <xs:documentation>In the deterministic serialization, the if and then  of a
                proof-theoretic entailment can occur in either order if striped. This pattern can be
                translated accurately into XSD.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:sequence>
                <xs:group ref="ruleml:body_Entails.name.choice"/>
                <xs:group ref="ruleml:head_Entails.name.choice"/>
            </xs:sequence>
            <xs:sequence>
                <xs:group ref="ruleml:head_Entails.name.choice"/>
                <xs:group ref="ruleml:body_Entails.name.choice"/>
            </xs:sequence>
            <xs:sequence>
                <xs:group ref="ruleml:body_Entails-ss.content"/>
                <xs:group ref="ruleml:head_Entails-ss.content"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <xs:group name="TruthValuedConnective.header">
        <xs:annotation>
            <xs:documentation>In the deterministic serialization, the order of header elements is:
                an optional header element sequence as defined in Node.header, followed by optional
                object identifier and degree</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:sequence minOccurs="0">
                <xs:group minOccurs="0" ref="ruleml:Node.header"/>
                <xs:group minOccurs="0" ref="ruleml:degree-edge.choice"/>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom.header">
        <xs:sequence>
            <xs:sequence minOccurs="0">
                <xs:group minOccurs="0" ref="ruleml:Node.header"/>
                <xs:group minOccurs="0" ref="ruleml:objectIdentifier-edge.choice"/>
                <xs:group minOccurs="0" ref="ruleml:degree-edge.choice"/>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:group name="Expr.header">
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:Node.header"/>
        </xs:sequence>
    </xs:group>
    
    
    <xs:group name="positionalArgument-edge.choice">
        <xs:annotation>
            <xs:documentation>Stripe-skipping is allowed for positional arguments in atomic formulas
                and expressions.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:arg.content"/>
            <xs:element ref="ruleml:arg"/>
        </xs:choice>
    </xs:group>
    <xs:group name="body_Entails-ss.content">
        <xs:sequence>
            <xs:group ref="ruleml:body_Entails.content"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="head_Entails-ss.content">
        <xs:sequence>
            <xs:group ref="ruleml:head_Entails.content"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="torso-edge.choice">
        <xs:annotation>
            <xs:documentation>Stripe-skipping is allowed asynchronously in
                equivalences.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:torso.content"/>
            <xs:element ref="ruleml:torso"/>
        </xs:choice>
    </xs:group>
    <xs:group name="leftSide-edge.choice">
        <xs:annotation>
            <xs:documentation>Stripe-skipping is allowed asynchronously in
                equations.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:left.content"/>
            <xs:element ref="ruleml:left"/>
        </xs:choice>
    </xs:group>
    <xs:group name="rightSide-edge.choice">
        <xs:choice>
            <xs:group ref="ruleml:right.content"/>
            <xs:element ref="ruleml:right"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_And-head-edge.choice">
        <xs:choice>
            <xs:group ref="ruleml:formula_And-head.content"/>
            <xs:group ref="ruleml:formula_And-head.edge.def"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Exists-head-edge.choice">
        <xs:choice>
            <xs:group ref="ruleml:formula_Exists-head.content"/>
            <xs:group ref="ruleml:formula_Exists-head.edge.def"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula_Rulebase-edge.choice">
        <xs:annotation>
            <xs:documentation>Stripe-skipping is allowed asynchronously for formulas in assertions
                and retractions.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:formula_Rulebase.content"/>
            <xs:group ref="ruleml:formula_Rulebase.edge.def"/>
        </xs:choice>
    </xs:group>
    <xs:group name="weak-edge.choice">
        <xs:annotation>
            <xs:documentation>Stripe-skipping is allowed for weak negations.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:weak.content"/>
            <xs:element ref="ruleml:weak"/>
        </xs:choice>
    </xs:group>
    <xs:group name="strong-edge.choice">
        <xs:annotation>
            <xs:documentation>Stripe-skipping is allowed for strong negations.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:strong.content"/>
            <xs:element ref="ruleml:strong"/>
        </xs:choice>
    </xs:group>
    
    
    
    
    <xs:simpleType name="AbsIRI.datatype">
        <xs:restriction base="xs:string">
            <xs:pattern value="[\i-[:]][\c-[:]]+:.+"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrefixedCURIE.datatype">
        <xs:restriction base="xs:string">
            <xs:pattern value="(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"/>
            <xs:minLength value="1"/>
        </xs:restriction>
    </xs:simpleType>
    
    <xs:attributeGroup name="Resource.attlist">
        <xs:annotation>
            <xs:documentation>attribute list for resources includes and optional iri
                attribute.</xs:documentation>
        </xs:annotation>
        <xs:attribute name="iri" type="ruleml:iri.value">
            <xs:annotation>
                <xs:documentation>An attribute for referring to a IRI.     See
                    http://deliberation.ruleml.org/1.03/glossary/.40iri</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="iri-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the oriented equation
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:iri.attrib.def"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="iri.attrib.def">
        <xs:attribute name="iri" type="ruleml:iri.value" use="required">
            <xs:annotation>
                <xs:documentation>An attribute for referring to a IRI.     See
                    http://deliberation.ruleml.org/1.03/glossary/.40iri</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="iri.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
    </xs:simpleType>
    
    
    
    <xs:group name="Rulebase-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the rulebase tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Rulebase"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Rulebase" type="ruleml:Rulebase.type.def">
        <xs:annotation>
            <xs:documentation>A collection of rules or formulas that can be ordered or unordered,
                without or with duplicates.  See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Rulebase</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Rulebase.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Rulebase.header"/>
            <xs:group ref="ruleml:Rulebase.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:Rulebase-datt.choice"/>
        <xs:attributeGroup ref="ruleml:reRulebase.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reRulebase.attlist">
        <xs:annotation>
            <xs:documentation>Rulebases may have an optional scope quantification closure
                attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:mapClosure-att.choice"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="Rulebase.header">
        <xs:annotation>
            <xs:documentation>Rulebases accept the header pattern common to
                Nodes.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:Node.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Rulebase.main">
        <xs:annotation>
            <xs:documentation>Rulebases contain zero or more formulas.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_Rulebase-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_Rulebase.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Rulebase.type.def">
                <xs:annotation>
                    <xs:documentation>The formula edge of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;)
                        expression,  quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt;
                        or &lt;Retract&gt;). See http://deliberation.ruleml.org/1.03/glossary/#gloss-formula
                        Within Rulebase ...</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Rulebase.type.def">
        <xs:group ref="ruleml:formula_Rulebase.content"/>
        <xs:attributeGroup ref="ruleml:formula_Rulebase.attlist"/>
    </xs:complexType>
    <xs:group name="formula_Rulebase.content">
        <xs:sequence>
            <xs:group ref="ruleml:RulebaseFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="RulebaseFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to belong to a Rulebase:  Atomic formulas are allowed
                in rulebases.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
            <xs:group ref="ruleml:Implication-node.choice"/>
            <xs:group ref="ruleml:Forall-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:attributeGroup name="formula_Rulebase.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    <xs:group name="Entails-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the entailment tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Entails"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Entails" type="ruleml:Entails.type.def">
        <xs:annotation>
            <xs:documentation>Well-known in (meta-) logic (earlier called 'Turnstile', and 'Demo' in
                Kowalski/Bowen's object/meta-level-amalgamated logic). See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Entails </xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Entails.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Entails.header"/>
            <xs:group ref="ruleml:Entails.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reEntails.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reEntails.attlist">
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Entails.header">
        <xs:annotation>
            <xs:documentation>Logical entailments accept the header pattern common to
                Nodes.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:Node.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="body_Entails.name.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the if tag name in entailments.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:body_Entails.edge.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="body_Entails.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="if" type="ruleml:body_Entails.type.def">
                <xs:annotation>
                    <xs:documentation>The if of an implication rule (&lt;Implies&gt;) containing the
                        Premise(s), also known as the "antecedent" part of the rule.  Also used as
                        the "antecedent" part of an entailment (&lt;Entails&gt;). See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-if  Within
                        Entails...</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="body_Entails.type.def">
        <xs:group ref="ruleml:body_Entails.content"/>
        <xs:attributeGroup ref="ruleml:body_Entails.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="body_Entails.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="body_Entails.content">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:EntailsFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="EntailsFormula.choice">
        <xs:annotation>
            <xs:documentation>The if of an entailment contains a single rulebase. as well as any
                single formula that is allowed in a Rulebase.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:RulebaseFormula.choice"/>
            <xs:group ref="ruleml:Rulebase-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="head_Entails.name.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the then tag name in entailments.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:head_Entails.edge.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="head_Entails.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="then" type="ruleml:head_Entails.type.def">
                <xs:annotation>
                    <xs:documentation>The then of an implication rule (&lt;Implies&gt;) containing the
                        conclusion, also known as the "consequent" or "then" part of the rule.  Also
                        used as the "consequent" part of an entailment (&lt;Entails&gt;). See
                        http://deliberation.ruleml.org/1.03/glossary/#gloss-then  within
                        Entails</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="head_Entails.type.def">
        <xs:group ref="ruleml:head_Entails.content"/>
        <xs:attributeGroup ref="ruleml:head_Entails.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="head_Entails.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="head_Entails.content">
        <xs:annotation>
            <xs:documentation>The then of an entailment has the same content model as the if
                part.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:EntailsFormula.choice"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="degree-edge.choice">
        <xs:sequence>
            <xs:element ref="ruleml:degree"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="degree" type="ruleml:degree.type.def">
        <xs:annotation>
            <xs:documentation>An optional uncertainty value (between 0.0 and 1.0) that may be
                assigned to formulas. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-degree</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="degree.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:degree.content">
                <xs:attributeGroup ref="ruleml:degree.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:attributeGroup name="degree.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="degree.content">
        <xs:annotation>
            <xs:documentation>The degree edge element contains a single data
                term.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ruleml:Data_degree-node.choice"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Data_degree-node.choice">
        <xs:group ref="ruleml:DataTerm.choice"/>
    </xs:complexType>
    
    <xs:group name="Negation-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the strong negation tag
                name.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Neg"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Neg" type="ruleml:Neg.type.def">
        <xs:annotation>
            <xs:documentation>A classical negation of a logical atom (&lt;Atom&gt;) (i.e. classical or
                "strong" negation).  The negated atom may be optionally surrounded by &lt;strong&gt; role
                tags.        See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Neg</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Neg.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Neg.header"/>
            <xs:group ref="ruleml:Neg.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reNeg.attlist"/>
    </xs:complexType>
    
    <xs:attributeGroup name="reNeg.attlist">
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Neg.header">
        <xs:annotation>
            <xs:documentation>Negation formulas accept the header pattern common to truth-valued
                connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Neg.main">
        <xs:annotation>
            <xs:documentation>The main section of a Negation formula contains a single "strong"
                edge.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:strong-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="strong" type="ruleml:strong.type.def">
        <xs:annotation>
            <xs:documentation>An edge used for logical negation (&lt;Neg&gt;).        See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-strong</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="strong.type.def">
        <xs:group ref="ruleml:strong.content"/>
        <xs:attributeGroup ref="ruleml:strong.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="strong.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="strong.content">
        <xs:annotation>
            <xs:documentation>The role filler for strong negation edges is a single formula.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:NegFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="NegFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to belong to strong negation formulas include atomic
                formulas. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="NegationAsFailure-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the weak negation tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Naf"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Naf" type="ruleml:Naf.type.def">
        <xs:annotation>
            <xs:documentation>A "by default" negation of a logical atom (&lt;Atom&gt;) (i.e. "weak" negation
                or negation as failure).  The negated atom may be optionally surrounded by &lt;weak&gt; role
                tags.        See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Naf</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Naf.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Naf.header"/>
            <xs:group ref="ruleml:Naf.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reNaf.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reNaf.attlist">
        <xs:annotation>
            <xs:documentation>The attribute list of the weak negation element will accept a scoped
                closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Naf.header">
        <xs:annotation>
            <xs:documentation>Negation As Failure formulas accept the header pattern common to
                truth-valued connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Naf.main">
        <xs:annotation>
            <xs:documentation>The main section of Negation As Failure formulas contains a single
                "weak" edge.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:weak-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="weak" type="ruleml:weak.type.def">
        <xs:annotation>
            <xs:documentation>An edge used for negation as failure (&lt;Naf&gt;).        See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-weak</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="weak.type.def">
        <xs:group ref="ruleml:weak.content"/>
        <xs:attributeGroup ref="ruleml:weak.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="weak.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="weak.content">
        <xs:annotation>
            <xs:documentation>The weak negation edge contains a single formula. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:NafFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="NafFormula.choice">
        <xs:annotation>
            <xs:documentation>formulas allowed to belong to weak negation formulas
            </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleFormula-node.choice"/>
            <xs:group ref="ruleml:Negation-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:attributeGroup name="commonNode.attlist">
        <xs:attribute name="node" type="ruleml:node.value">
            <xs:annotation>
                <xs:documentation>An attribute for referring to a IRI.     See
                    http://deliberation.ruleml.org/1.03/glossary/.40node</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="node-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the node attribute name.
            </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:node.attrib.def"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="node.attrib.def">
        <xs:attribute name="node" type="ruleml:node.value" use="required">
            <xs:annotation>
                <xs:documentation>An attribute for referring to a IRI.     See
                    http://deliberation.ruleml.org/1.03/glossary/.40node</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="node.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
    </xs:simpleType>
    
    
    
    <xs:group name="metaKnowledge-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the meta-knowledge tag name.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:meta"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="meta" type="ruleml:meta.type.def">
        <xs:annotation>
            <xs:documentation>&lt;meta&gt;: a container for meta-knowledge. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-meta</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="meta.type.def">
        <xs:group ref="ruleml:AssertRetractFormula.choice"/>
        <xs:attributeGroup ref="ruleml:meta.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="meta.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    <xs:group name="Node.header">
        <xs:annotation>
            <xs:documentation>The header for Nodes allows an arbitrary number of &lt;meta&gt;
                elements.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:metaKnowledge-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:attributeGroup name="xmlbase.attlist">
        <xs:annotation>
            <xs:documentation> </xs:documentation>
        </xs:annotation>
        <xs:attribute ref="xml:base"/>
    </xs:attributeGroup>
    
    
    <xs:attributeGroup name="xmlid.attlist">
        <xs:annotation>
            <xs:documentation> </xs:documentation>
        </xs:annotation>
        <xs:attribute ref="xml:id"/>
    </xs:attributeGroup>
    
    
    
    <xs:group name="Equivalent-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the equivalence tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Equivalent"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Equivalent" type="ruleml:Equivalent.type.def">
        <xs:annotation>
            <xs:documentation>&lt;Equivalent&gt;: Syntactic sugar for two implications. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Equivalent </xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Equivalent.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Equivalent.header"/>
            <xs:group ref="ruleml:Equivalent.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reEquivalent.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reEquivalent.attlist">
        <xs:annotation>
            <xs:documentation>Equivalences may have an optional closure attribute  and will accept a
                scoped closure attribute at full first-order logic.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:group name="Equivalent.header">
        <xs:annotation>
            <xs:documentation>Equivalences accept the header pattern common to truth-valued
                connectives.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Equivalent.main">
        <xs:annotation>
            <xs:documentation>the main section of an equivalance contains of two "torso"
                edges</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:torso-edge.choice"/>
            <xs:group ref="ruleml:torso-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="torso" type="ruleml:torso.type.def">
        <xs:annotation>
            <xs:documentation>&lt;torso&gt;: contains one formula within an equivalence. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-torso </xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="torso.type.def">
        <xs:group ref="ruleml:torso.content"/>
        <xs:attributeGroup ref="ruleml:torso.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="torso.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="torso.content">
        <xs:annotation>
            <xs:documentation>An equivalance is syntactic sugar for two implications. In all RuleML
                languages, formulas allowed as premises are the same or more general than those
                allowed as conclusions, because this is a requirement for the statement "P implies
                P" to be syntactically valid whenever P is a valid conclusion. Therefore, the torso
                roles in equivalences may be filled by the same formulas as those allowed in
                conclusions.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:ConclusionFormula.choice"/>
        </xs:sequence>
    </xs:group>
    
    
    <xs:attributeGroup name="direction-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the inference direction
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="direction" type="ruleml:direction.value">
            <xs:annotation>
                <xs:documentation> An attribute indicating the intended direction of an implication
                    rule's (&lt;Implies&gt;) inferencing.  It has a neutral value of "bidirectional". Other
                    predefined values are "forward" and "backward". See
                    http://deliberation.ruleml.org/1.03/glossary/.40direction</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="direction.attrib.def">
        <xs:attribute name="direction" type="ruleml:direction.value" use="required">
            <xs:annotation>
                <xs:documentation> An attribute indicating the intended direction of an implication
                    rule's (&lt;Implies&gt;) inferencing.  It has a neutral value of "bidirectional". Other
                    predefined values are "forward" and "backward". See
                    http://deliberation.ruleml.org/1.03/glossary/.40direction</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="direction.value">
        <xs:union memberTypes="ruleml:direction_default.value ruleml:direction_non-default.value"/>
    </xs:simpleType>
    
    
    
    <xs:attributeGroup name="mapDirection-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the scope inference
                direction attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="mapDirection" type="ruleml:mapDirection.value">
            <xs:annotation>
                <xs:documentation> An attribute indicating the intended direction of implication
                    rule (&lt;Implies&gt;) inferencing of elements  falling within its scope (i.e. child
                    elements). See attribute mapping for more details. This attribute has a  neutral
                    default value of "bidirectional". Other predefined values are "forward" and
                    "backward". See
                    http://deliberation.ruleml.org/1.03/glossary/.40mapDirection</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="mapDirection.attrib.def">
        <xs:attribute name="mapDirection" type="ruleml:mapDirection.value" use="required">
            <xs:annotation>
                <xs:documentation> An attribute indicating the intended direction of implication
                    rule (&lt;Implies&gt;) inferencing of elements  falling within its scope (i.e. child
                    elements). See attribute mapping for more details. This attribute has a  neutral
                    default value of "bidirectional". Other predefined values are "forward" and
                    "backward". See
                    http://deliberation.ruleml.org/1.03/glossary/.40mapDirection</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="mapDirection.value">
        <xs:restriction base="ruleml:direction.value"/>
    </xs:simpleType>
    
    
    
    <xs:simpleType name="direction_non-default.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="forward"/>
                    <xs:enumeration value="backward"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    
    <xs:simpleType name="direction_default.value">
        <xs:restriction base="xs:token">
            <xs:enumeration value="bidirectional"/>
        </xs:restriction>
    </xs:simpleType>
    
    <xs:attributeGroup name="material-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the material implication
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="material" type="ruleml:material.value">
            <xs:annotation>
                <xs:documentation> An attribute indicating the kind of an implication rule
                    (&lt;Implies&gt;). Predefined values are "yes" (the default) and "no". See
                    http://deliberation.ruleml.org/1.03/glossary/.40material</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="material.attrib.def">
        <xs:attribute name="material" type="ruleml:material.value" use="required">
            <xs:annotation>
                <xs:documentation> An attribute indicating the kind of an implication rule
                    (&lt;Implies&gt;). Predefined values are "yes" (the default) and "no". See
                    http://deliberation.ruleml.org/1.03/glossary/.40material</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="material.value">
        <xs:union memberTypes="ruleml:material_default.value ruleml:material_non-default.value"/>
    </xs:simpleType>
    
    
    
    <xs:attributeGroup name="mapMaterial-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the scope material
                implication attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="mapMaterial" type="ruleml:mapMaterial.value">
            <xs:annotation>
                <xs:documentation> An attribute indicating the kind of all implication rules
                    (&lt;Implies&gt;) falling within its scope (i.e. child elements).   Predefined values
                    are "yes" (the default) and "no". See
                    http://deliberation.ruleml.org/1.03/glossary/.40mapMaterial</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="mapMaterial.attrib.def">
        <xs:attribute name="mapMaterial" type="ruleml:mapMaterial.value" use="required">
            <xs:annotation>
                <xs:documentation> An attribute indicating the kind of all implication rules
                    (&lt;Implies&gt;) falling within its scope (i.e. child elements).   Predefined values
                    are "yes" (the default) and "no". See
                    http://deliberation.ruleml.org/1.03/glossary/.40mapMaterial</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="mapMaterial.value">
        <xs:restriction base="ruleml:material.value"/>
    </xs:simpleType>
    
    
    
    <xs:simpleType name="material_non-default.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="no"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    
    <xs:simpleType name="material_default.value">
        <xs:restriction base="xs:token">
            <xs:enumeration value="yes"/>
        </xs:restriction>
    </xs:simpleType>
    
    <xs:group name="Exists-head.Node.def">
        <xs:sequence>
            <xs:element form="qualified" name="Exists" type="ruleml:Exists-head.type.def">
                <xs:annotation>
                    <xs:documentation>within the head of implications</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Exists-head.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Exists.header"/>
            <xs:group ref="ruleml:Exists-head.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reExists.attlist"/>
    </xs:complexType>
    <xs:group name="Exists-head.main">
        <xs:sequence>
            <xs:group ref="ruleml:boundVariables.choice"/>
            <xs:group ref="ruleml:formula_Exists-head-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_Exists-head.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_Exists-head.type.def">
                <xs:annotation>
                    <xs:documentation>within the head of implications</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_Exists-head.type.def">
        <xs:group ref="ruleml:formula_Exists-head.content"/>
        <xs:attributeGroup ref="ruleml:formula_Exists.attlist"/>
    </xs:complexType>
    <xs:group name="formula_Exists-head.content">
        <xs:annotation>
            <xs:documentation> </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:ExistsHeadFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="ExistsHeadFormula.choice">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Atom-node.choice"/>
            <xs:group ref="ruleml:And-head-node.choice"/>
            <xs:group ref="ruleml:Or-head-node.choice"/>
            <xs:group ref="ruleml:Negation-head-node.choice"/>
            <xs:group ref="ruleml:Exists-head-node.choice"/>
        </xs:choice>
    </xs:group>
    <xs:group name="And-head.Node.def">
        <xs:sequence>
            <xs:element form="qualified" name="And" type="ruleml:And-head.type.def">
                <xs:annotation>
                    <xs:documentation>within the head of implications</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="And-head.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:And.header"/>
            <xs:group ref="ruleml:And-head.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:reAnd.attlist"/>
    </xs:complexType>
    <xs:group name="And-head.main">
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_And-head-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="formula_And-head.edge.def">
        <xs:sequence>
            <xs:element form="qualified" name="formula" type="ruleml:formula_And-head.type.def">
                <xs:annotation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="formula_And-head.type.def">
        <xs:group ref="ruleml:formula_And-head.content"/>
        <xs:attributeGroup ref="ruleml:formula_And-datt.choice"/>
        <xs:attributeGroup ref="ruleml:formula_And.attlist"/>
    </xs:complexType>
    <xs:group name="formula_And-head.content">
        <xs:sequence>
            <xs:group ref="ruleml:AndHeadFormula.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="AndHeadFormula.choice">
        <xs:choice>
            <xs:group ref="ruleml:Atom-node.choice"/>
            <xs:group ref="ruleml:And-head-node.choice"/>
            <xs:group ref="ruleml:Or-head-node.choice"/>
            <xs:group ref="ruleml:Negation-head-node.choice"/>
            <xs:group ref="ruleml:Exists-head-node.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:group name="objectIdentifier-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for stripe skipping as well as specializations of
                the object identifier tag name.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:oid"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="oid" type="ruleml:oid.type.def">
        <xs:annotation>
            <xs:documentation>&lt;oid&gt;: a label for Node elements. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-oid</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="oid.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:oid.content">
                <xs:attributeGroup ref="ruleml:oid.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:attributeGroup name="oid.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="oid.content">
        <xs:annotation>
            <xs:documentation>The object descriptor content model consists of any single term. Note:
                this corrects an error in the oid content model of RuleML 1.0, where Var is allowed
                in oid in bindatagroundlog and bindatagroundfact.</xs:documentation>
        </xs:annotation>
        <xs:group ref="ruleml:AnyTerm.choice"/>
    </xs:complexType>
    
    <xs:group name="slotTerms.sequence">
        <xs:annotation>
            <xs:documentation>In atomic formulas, zero or more slots are allowed.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:slot-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="slotTermsForAtoms.sequence">
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:slotTerms.sequence"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="slotTermsForExpressions.sequence">
        <xs:annotation>
            <xs:documentation>In expressions, zero or more slots are allowed.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:slotTerms.sequence"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="slot-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the slot tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:slot"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="slot" type="ruleml:slot.type.def">
        <xs:annotation>
            <xs:documentation>A user-defined slot (property). See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-slot</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="slot.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:slot.content">
                <xs:attributeGroup ref="ruleml:reslot.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:attributeGroup name="reslot.attlist">
        <xs:annotation>
            <xs:documentation>The slot element accepts optional cardinality and  weight attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:cardinality-att.choice"/>
        <xs:attributeGroup ref="ruleml:weight-att.choice"/>
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="slot.content">
        <xs:annotation>
            <xs:documentation>The slot content model consists of a key (first position) and a filler
                (second position).</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:slotKeyTerm.choice"/>
            <xs:group ref="ruleml:slotFillerTerm.choice"/>
        </xs:sequence>
    </xs:complexType>
    <xs:group name="slotKeyTerm.choice">
        <xs:annotation>
            <xs:documentation>The key (first position) in a slot contains an interpreted term or
                data, which may be simple or compound.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:SimpleKeyTerm.choice"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="slotFillerTerm.choice">
        <xs:annotation>
            <xs:documentation>The filler (second position) in a slot contains any single
                term.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:AnyTerm.choice"/>
        </xs:sequence>
    </xs:group>
    
    
    <xs:attributeGroup name="cardinality-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the cardinality attribute
                name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="card" type="ruleml:cardinality.value">
            <xs:annotation>
                <xs:documentation>the cardinality of a slot.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="card.attrib.def">
        <xs:annotation>
            <xs:documentation>An attribute optionally specifying a &lt;slot&gt;'s cardinality. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-card</xs:documentation>
        </xs:annotation>
        <xs:attribute name="card" type="ruleml:cardinality.value" use="required">
            <xs:annotation>
                <xs:documentation>the cardinality of a slot.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="cardinality.value">
        <xs:restriction base="xs:nonNegativeInteger"/>
    </xs:simpleType>
    
    
    
    <xs:attributeGroup name="weight-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the weight attribute name.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="weight" type="ruleml:weight.datatype">
            <xs:annotation>
                <xs:documentation>An attribute optionally specifying a &lt;slot&gt;'s relative weight. See
                    http://deliberation.ruleml.org/1.03/glossary/#gloss-weight</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="weight.attrib.def">
        <xs:attribute name="weight" type="ruleml:weight.datatype" use="required">
            <xs:annotation>
                <xs:documentation>An attribute optionally specifying a &lt;slot&gt;'s relative weight. See
                    http://deliberation.ruleml.org/1.03/glossary/#gloss-weight</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    
    <xs:simpleType name="weight.datatype">
        <xs:annotation>
            <xs:documentation>When representing a weight or probability, the content of the Data
                element is constrained to values between 0 and 1, inclusive. </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:decimal">
            <xs:minInclusive value="0.0"/>
            <xs:maxInclusive value="1.0"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:attributeGroup name="weight.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    
    
    <xs:group name="Equal-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the equation tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Equal"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Equal" type="ruleml:Equal.type.def">
        <xs:annotation>
            <xs:documentation>&lt;Equal&gt;: an equation between two terms. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Equal</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Equal.type.def">
        <xs:sequence>
            <xs:group ref="ruleml:Equal.header"/>
            <xs:group ref="ruleml:Equal.main"/>
        </xs:sequence>
        <xs:attributeGroup ref="ruleml:Equal-datt.choice"/>
        <xs:attributeGroup ref="ruleml:reEqual.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="reEqual.attlist">
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:group name="Equal.header">
        <xs:annotation>
            <xs:documentation>Equations accept the header of truth-valued
                connectives</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Equal.main">
        <xs:annotation>
            <xs:documentation>The main section of equations contains a pair of edges, a left-hand
                side edge and a right-hand side edge.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:leftSide-edge.choice"/>
            <xs:group ref="ruleml:rightSide-edge.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="left" type="ruleml:left.type.def">
        <xs:annotation>
            <xs:documentation>&lt;left&gt;: The left-hand side edge of an equation. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-left</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="left.type.def">
        <xs:group ref="ruleml:left.content"/>
        <xs:attributeGroup ref="ruleml:left.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="left.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="left.content">
        <xs:annotation>
            <xs:documentation>The left-hand side role in an equation is filled by a
                term.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:leftTerm.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="right" type="ruleml:right.type.def">
        <xs:annotation>
            <xs:documentation>&lt;right&gt;: The right-hand side edge of an equation. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-right</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="right.type.def">
        <xs:group ref="ruleml:right.content"/>
        <xs:attributeGroup ref="ruleml:right.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="right.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:group name="right.content">
        <xs:annotation>
            <xs:documentation>The right-hand side role in an equation is filled by a
                term.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:rightTerm.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="leftTerm.choice">
        <xs:annotation>
            <xs:documentation>terms allowed in the left-hand side of an equation </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:AnyTerm.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="rightTerm.choice">
        <xs:annotation>
            <xs:documentation>terms allowed in the right-hand side of an equation
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:AnyTerm.choice"/>
        </xs:sequence>
    </xs:group>
    
    <xs:attributeGroup name="oriented-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the oriented equation
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="oriented" type="ruleml:oriented.value">
            <xs:annotation>
                <xs:documentation>An attribute indicating whether an equation (&lt;Equal&gt;) is oriented
                    (directed) or unoriented (symmetric).        See
                    http://deliberation.ruleml.org/1.03/glossary/.40oriented</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="oriented.attrib.def">
        <xs:attribute name="oriented" type="ruleml:oriented.value" use="required">
            <xs:annotation>
                <xs:documentation>An attribute indicating whether an equation (&lt;Equal&gt;) is oriented
                    (directed) or unoriented (symmetric).        See
                    http://deliberation.ruleml.org/1.03/glossary/.40oriented</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="oriented.value">
        <xs:union memberTypes="ruleml:oriented_default.value ruleml:oriented_non-default.value"/>
    </xs:simpleType>
    
    
    
    <xs:simpleType name="oriented_non-default.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="yes"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    
    <xs:simpleType name="oriented_default.value">
        <xs:restriction base="xs:token">
            <xs:enumeration value="no"/>
        </xs:restriction>
    </xs:simpleType>
    
    <xs:attributeGroup name="Type.attlist">
        <xs:annotation>
            <xs:documentation>attribute list for objects that can have user-defined types, includes
                an optional type attribute.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:type-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="type-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the oriented equation
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="type" type="ruleml:type.value">
            <xs:annotation>
                <xs:documentation>An attribute for optionally refining a term's (user-defined) type.
                    See http://deliberation.ruleml.org/1.03/glossary/#gloss-type</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="type.attrib.def">
        <xs:attribute name="type" type="ruleml:type.value" use="required">
            <xs:annotation>
                <xs:documentation>An attribute for optionally refining a term's (user-defined) type.
                    See http://deliberation.ruleml.org/1.03/glossary/#gloss-type</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="type.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
    </xs:simpleType>
    
    
    
    <xs:group name="DataTerm.choice">
        <xs:annotation>
            <xs:documentation>Data terms may have mixed content from any
                namespace.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Data_any-node.choice"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Data_any-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the data tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Data"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Data" type="xs:anyType"/>
    
    
    <xs:group name="anyElement.choice">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:anyElement.def"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="anyElement.def">
        <xs:sequence>
            <xs:any processContents="lax"/>
        </xs:sequence>
    </xs:group>
    
    <xs:group name="Skolem-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point to allow alternate names and internationalization
                for Skolem constants</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Skolem"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Skolem" type="ruleml:Skolem.type.def">
        <xs:annotation>
            <xs:documentation>A Skolem individual constant, like RDF's blank nodes. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Skolem</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Skolem.type.def">
        <xs:simpleContent>
            <xs:extension base="ruleml:Skolem.value">
                <xs:attributeGroup ref="ruleml:reSkolem.attlist"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="reSkolem.attlist">
        <xs:annotation>
            <xs:documentation>Skolems optionally accept the attribute pattern of objects with
                user-defined types.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:Type.attlist"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    </xs:attributeGroup>
    <xs:simpleType name="Skolem.value">
        <xs:annotation>
            <xs:documentation>The content model for skolems is the XSD datatype
                token.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token"/>
    </xs:simpleType>
    
    <xs:group name="Reify-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point to allow alternate names and internationalization
                for reification</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Reify"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Reify"><xs:complexType><xs:sequence><xs:any minOccurs="0" processContents="strict" namespace="##targetNamespace"/></xs:sequence><xs:attributeGroup ref="ruleml:commonNode.attlist"/></xs:complexType></xs:element>
    
    
    
    
    <xs:group name="AnyThis.def">
        <xs:sequence>
            <xs:any namespace="##targetNamespace" processContents="lax"/>
        </xs:sequence>
    </xs:group>
    
    <xs:element name="arg" type="ruleml:arg.type.def">
        <xs:annotation>
            <xs:documentation>&lt;arg&gt;: one argument of an atomic formula. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-arg</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="arg.type.def">
        <xs:annotation>
            <xs:documentation>The attribute @index is required for the positional argument
                role.</xs:documentation>
        </xs:annotation>
        <xs:group ref="ruleml:arg.content"/>
        <xs:attributeGroup ref="ruleml:arg-datt.choice"/>
        <xs:attributeGroup ref="ruleml:rearg.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="arg-datt.choice">
        <xs:attributeGroup ref="ruleml:index.attrib.def"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="rearg.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="index-attrib.choice">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:attribute name="index" type="ruleml:index.value">
            <xs:annotation>
                <xs:documentation>A required attribute for specifying the position of a positional
                    argument (&lt;arg&gt;) within a logical atom (&lt;Atom&gt;). See
                    http://deliberation.ruleml.org/1.03/glossary/#gloss-index</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="index.attrib.def">
        <xs:attribute name="index" type="ruleml:index.value" use="required">
            <xs:annotation>
                <xs:documentation>A required attribute for specifying the position of a positional
                    argument (&lt;arg&gt;) within a logical atom (&lt;Atom&gt;). See
                    http://deliberation.ruleml.org/1.03/glossary/#gloss-index</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="index.value">
        <xs:restriction base="xs:positiveInteger"/>
    </xs:simpleType>
    <xs:group name="arg.content">
        <xs:annotation>
            <xs:documentation>The role filler for positional arguments edges in atomic formulas is a
                term.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:AnyTerm.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="AnyTerm.choice">
        <xs:annotation>
            <xs:documentation>Terms may be simple or compound. Simple terms are either constant or
                quantifiable (variable).</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:SimpleConstantTerm.choice"/>
            <xs:group ref="ruleml:SimpleQuantifiableTerm.choice"/>
        </xs:choice>
    </xs:group>
    
    <xs:group name="SimpleConstantTerm.choice">
        <xs:annotation>
            <xs:documentation>Skolem constants are simple constant terms, but are not used in keys.
            </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Skolem-node.choice"/>
            <xs:group ref="ruleml:Reify-node.choice"/>
            <xs:group ref="ruleml:SimpleKeyTerm.choice"/>
        </xs:choice>
    </xs:group>
    
    
    <xs:group name="SimpleKeyTerm.choice">
        <xs:annotation>
            <xs:documentation>Individuals and literals (data) are simple, constant terms, and may be
                used in slot keys.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ruleml:Individual-node.choice"/>
            <xs:group ref="ruleml:DataTerm.choice"/>
        </xs:choice>
    </xs:group>
    
    
    <xs:group name="Individual-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the individual tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Ind"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Ind" type="ruleml:Ind.type.def">
        <xs:annotation>
            <xs:documentation>&lt;Ind&gt;: an individual constant. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Ind</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Ind.type.def">
        <xs:simpleContent>
            <xs:extension base="ruleml:Ind.value">
                <xs:attributeGroup ref="ruleml:reInd.attlist"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="reInd.attlist">
        <xs:annotation>
            <xs:documentation>Individuals optionally accept the attribute patterns of resources, and
                objects with user-defined types.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:Resource.attlist"/>
        <xs:attributeGroup ref="ruleml:Type.attlist"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    </xs:attributeGroup>
    
    <xs:simpleType name="Ind.value">
        <xs:annotation>
            <xs:documentation>The content model for individuals is the XSD datatype
                token.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token"/>
    </xs:simpleType>
    <xs:group name="termsForAtoms.sequence">
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:termsForAtoms.nonemptysequence.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="termsForExpressions.sequence">
        <xs:sequence>
            <xs:group minOccurs="0" ref="ruleml:termsForExpressions.nonemptysequence.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:attributeGroup name="commonInit.attlist">
        <xs:annotation>
            <xs:documentation/>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:xmlid.attlist"/>
        <xs:attribute name="key" type="ruleml:key.value"/>
        <xs:attribute name="keyref" type="ruleml:keyref.value"/>
    </xs:attributeGroup>
    
    <xs:group name="SimpleQuantifiableTerm.choice">
        <xs:annotation>
            <xs:documentation>terms that can be bound by a quantifier include
                variables.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="ruleml:Variable-node.choice"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Variable-node.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the variable tag name.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:Var"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="Var" type="ruleml:Var.type.def">
        <xs:annotation>
            <xs:documentation>A logical variable, as in logic programming. See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-Var</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="Var.type.def">
        <xs:simpleContent>
            <xs:extension base="ruleml:Var.value">
                <xs:attributeGroup ref="ruleml:reVar.attlist"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="reVar.attlist">
        <xs:annotation>
            <xs:documentation>Variables optionally accept the attribute pattern of objects with
                user-defined types.</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:Type.attlist"/>
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    </xs:attributeGroup>
    <xs:simpleType name="Var.value">
        <xs:annotation>
            <xs:documentation>The content model for variables is the XSD datatype
                token.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token"/>
    </xs:simpleType>
    
    <xs:attributeGroup name="closure-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the implicit closure
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="closure" type="ruleml:closure.value">
            <xs:annotation>
                <xs:documentation>An attribute indicating how the in-scope free variables are
                    quantified.  Predefined values are "universal" and "existential". See
                    http://deliberation.ruleml.org/1.03/glossary/#.40closure</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="closure.attrib.def">
        <xs:attribute name="closure" type="ruleml:closure.value" use="required">
            <xs:annotation>
                <xs:documentation>An attribute indicating how the in-scope free variables are
                    quantified.  Predefined values are "universal" and "existential". See
                    http://deliberation.ruleml.org/1.03/glossary/#.40closure</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="closure.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="universal"/>
                    <xs:enumeration value="existential"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    
    
    
    <xs:attributeGroup name="mapClosure-att.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the scope implicit closure
                attribute name.  </xs:documentation>
        </xs:annotation>
        <xs:attribute name="mapClosure" type="ruleml:mapClosure.value">
            <xs:annotation>
                <xs:documentation>An attribute indicating how the free variables falling within its
                    scope (i.e. child elements) are quantified.  Predefined values are "universal"
                    and "existential". See
                    http://deliberation.ruleml.org/1.03/glossary/.40mapClosure</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="mapClosure.attrib.def">
        <xs:attribute name="mapClosure" type="ruleml:mapClosure.value" use="required">
            <xs:annotation>
                <xs:documentation>An attribute indicating how the free variables falling within its
                    scope (i.e. child elements) are quantified.  Predefined values are "universal"
                    and "existential". See
                    http://deliberation.ruleml.org/1.03/glossary/.40mapClosure</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="mapClosure.value">
        <xs:restriction base="ruleml:closure.value"/>
    </xs:simpleType>
    
    
    
    <xs:group name="restOfSlots-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the slotted rest tag name.
                Stripe-skipping is not allowed for slotted rest variables.  </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:resl"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="resl" type="ruleml:resl.type.def">
        <xs:annotation>
            <xs:documentation>A slotted rest variable used in &lt;Atom&gt;s, &lt;Expr&gt;s and &lt;Plex&gt;s.  See
                http://deliberation.ruleml.org/1.03/glossary/#gloss-resl</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="resl.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:resl.content">
                <xs:attributeGroup ref="ruleml:resl.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="resl.content">
        <xs:annotation>
            <xs:documentation>The content model of a slotted rest variable is a single
                term.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ruleml:reslTerm.choice"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="reslTerm.choice">
        <xs:annotation>
            <xs:documentation>terms allowed in slotted rest variables. </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ruleml:SlotSequenceMarker.choice"/>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="SlotSequenceMarker.choice">
        <xs:annotation>
            <xs:documentation>Sequence markers are represented as ordinary
                variables.</xs:documentation>
        </xs:annotation>
        <xs:group ref="ruleml:Variable-node.choice"/>
    </xs:complexType>
    
    <xs:attributeGroup name="resl.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    <xs:group name="restOfPositionalArguments-edge.choice">
        <xs:annotation>
            <xs:documentation>an extension point for specializations of the positional rest tag
                name.  Stripe-skipping is not allowed for positional rest variables.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="ruleml:repo"/>
        </xs:sequence>
    </xs:group>
    <xs:element name="repo" type="ruleml:repo.type.def">
        <xs:annotation>
            <xs:documentation>A positional rest variable used in &lt;Atom&gt;s, &lt;Expr&gt;s and &lt;Plex&gt;s.         See
                http://www.ruleml.org/0.9/glossary/#gloss-repo</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="repo.type.def">
        <xs:complexContent>
            <xs:extension base="ruleml:repo.content">
                <xs:attributeGroup ref="ruleml:repo.attlist"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="repo.content">
        <xs:annotation>
            <xs:documentation>The content model of a positional rest variable is a single
                term.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ruleml:repoTerm.choice"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="repoTerm.choice">
        <xs:annotation>
            <xs:documentation>terms allowed in positional rest variables include sequence markers.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ruleml:SequenceMarker.choice"/>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="SequenceMarker.choice">
        <xs:annotation>
            <xs:documentation>Sequence markers are represented as ordinary
                variables.</xs:documentation>
        </xs:annotation>
        <xs:group ref="ruleml:Variable-node.choice"/>
    </xs:complexType>
    
    <xs:attributeGroup name="repo.attlist">
        <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    </xs:attributeGroup>
    
    
    
    
    
    
    
    
    <xs:attributeGroup name="reExpr.attlist">
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    
    
    
    
    
    
    
    <xs:attributeGroup name="style-att.choice">
        <xs:attribute name="style" type="ruleml:style.value">
            <xs:annotation>
                <xs:documentation>@style: defines a reference to a semantic profile. See
                    http://deliberation.ruleml.org/1.03/glossary/#.40style</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <xs:attributeGroup name="key-att.choice">
        <xs:annotation>
            <xs:documentation>@key: defines a unique key attribute which can be used for distributed
                referencing from a keyref attribute. See
                http://deliberation.ruleml.org/1.03/glossary/#.40key</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:key.attrib.def"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="key.attrib.def">
        <xs:attribute name="key" type="ruleml:key.value" use="required"/>
    </xs:attributeGroup>
    <xs:simpleType name="key.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
    </xs:simpleType>
    <xs:attributeGroup name="keyref-att.choice">
        <xs:annotation>
            <xs:documentation>@keyref: defines a reference to a corresponding unique key. See
                http://deliberation.ruleml.org/1.03/glossary/#.40keyref</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="ruleml:keyref.attrib.def"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="keyref.attrib.def">
        <xs:attribute name="keyref" type="ruleml:keyref.value" use="required"/>
    </xs:attributeGroup>
    <xs:simpleType name="keyref.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
    </xs:simpleType>
    
    
    
    
    <xs:attributeGroup name="style.attrib.def">
        <xs:attribute name="style" type="ruleml:style.value" use="required">
            <xs:annotation>
                <xs:documentation>@style: defines a reference to a semantic profile. See
                    http://deliberation.ruleml.org/1.03/glossary/#.40style</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="style.value">
        <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
    </xs:simpleType>
    
    <xs:attributeGroup name="generic-Node.attlist">
        <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
        <xs:attributeGroup ref="ruleml:type-att.choice"/>
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="generic-Formula.attlist">
        <xs:attributeGroup ref="ruleml:generic-Node.attlist"/>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="formula-interface-ext.attlist">
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="formula-interface.attlist">
        <xs:attributeGroup ref="ruleml:formula-interface-ext.attlist"/>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="operator-interface-ext.attlist">
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="operator-interface.attlist">
        <xs:attributeGroup ref="ruleml:operator-interface-ext.attlist"/>
        <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    </xs:attributeGroup>
    
    
    <xs:attributeGroup name="rePlex.attlist">
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="Tuple.attlist">
        <xs:attributeGroup ref="ruleml:style-att.choice"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="reFun.attlist">
        <xs:attributeGroup ref="ruleml:type-att.choice"/>
    </xs:attributeGroup>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
</xs:schema>